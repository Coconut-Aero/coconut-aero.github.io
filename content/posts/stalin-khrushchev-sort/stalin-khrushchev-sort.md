---
# type: docs 
title: 斯大林-赫鲁晓夫排序
date: 2025-01-30T20:32:21+08:00
featured: false
description: 斯大林-赫鲁晓夫排序（Stalin-Khrushchev Sort）——肃清与平反的排序艺术
comment: true
toc: true
draft: true
reward: true
pinned: false
carousel: false
series:
categories: [AI内容,算法]
tags: []
images: []
---

Generated by ChatGPT

# 斯大林-赫鲁晓夫排序
**描述**: 斯大林-赫鲁晓夫排序（Stalin-Khrushchev Sort）是一种结合筛选和修正的排序方法，在初始阶段采用严格的元素筛选，并在后续阶段对被筛选的元素进行修正。

---

## **算法实现（C++ 和 Java 版）**

我们采用 C++ 和 Java 来实现该算法，分别展示不同语言下的实现方式。

### **C++ 实现**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> StalinKhrushchevSort(const vector<int>& arr) {
    vector<int> StalinSorted, removed, result;
    
    int last = arr[0];
    StalinSorted.push_back(last);
    for (size_t i = 1; i < arr.size(); i++) {
        if (arr[i] >= last) {
            last = arr[i];
            StalinSorted.push_back(last);
        } else {
            removed.push_back(arr[i]);  
        }
    }

    result = StalinSorted;
    for (int num : removed) {
        auto pos = upper_bound(result.begin(), result.end(), num);
        result.insert(pos, num);
    }

    return result;
}

int main() {
    vector<int> arr = {4, 3, 7, 8, 6, 9, 5, 10, 2};
    vector<int> sortedArr = StalinKhrushchevSort(arr);

    cout << "Sorted array: ";
    for (int num : sortedArr) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

---

### **Java 实现**
```java
import java.util.*;

public class StalinKhrushchevSort {
    public static List<Integer> StalinKhrushchevSort(List<Integer> arr) {
        List<Integer> StalinSorted = new ArrayList<>();
        List<Integer> removed = new ArrayList<>();

        // 斯大林排序阶段
        int last = arr.get(0);
        StalinSorted.add(last);
        for (int i = 1; i < arr.size(); i++) {
            if (arr.get(i) >= last) {
                last = arr.get(i);
                StalinSorted.add(last);
            } else {
                removed.add(arr.get(i));  // 记录被“肃清”的元素
            }
        }

        // 赫鲁晓夫平反（对删除元素进行正确插入）
        List<Integer> result = new ArrayList<>(StalinSorted);
        for (int num : removed) {
            int pos = Collections.binarySearch(result, num);
            if (pos < 0) {
                pos = -(pos + 1);
            }
            result.add(pos, num);
        }

        return result;
    }

    public static void main(String[] args) {
        List<Integer> arr = Arrays.asList(4, 3, 7, 8, 6, 9, 5, 10, 2);
        List<Integer> sortedArr = StalinKhrushchevSort(arr);
        System.out.println("Sorted array: " + sortedArr);
    }
}
```

---

## **算法分析**

### **时间复杂度**
1. **初步排序阶段**：遍历数组一次，O(n)。
2. **修正阶段**：
   - 使用二分查找找到插入位置 O(log n)。
   - 每次插入操作的最坏情况是 O(n)（如果使用 `vector` 或 `ArrayList`，需要移动元素）。
   - 插入操作最多执行 n 次，因此最坏情况下总复杂度为 O(n²)。

综上，最坏情况下的时间复杂度为 **O(n²)**，但如果大多数元素在第一次排序阶段已经有序，则可以接近 **O(n log n)**。

### **空间复杂度**
- 额外存储 `removed` 列表，最坏情况下包含 `n` 个元素，O(n)。
- 额外存储 `StalinSorted` 和 `result`，O(n)。
- **总空间复杂度** 为 O(n)。

---

## **总结**

斯大林-赫鲁晓夫排序在原始斯大林排序的基础上进行了改进，使其能够保持完整的数据排序，而不是单纯地丢弃元素。尽管最坏情况下的时间复杂度可能达到 O(n²)，但在大多数情况下，它能够以接近 O(n log n) 的性能运行。
